---
slug: 2024-i18n-ai
title: ä½¿ç”¨gptæ¥åšå›½é™…åŒ–ç¿»è¯‘
date: 2024-9-5
authors:
  name: å¤§èŠ’æœ
  title: å‰ç«¯ / 25å±Š
  url: https://github.com/mongoRolls
  image_url: /img/logo.webp
tags: [æ€»ç»“ä¸è§„åˆ’]
keywords: [æ€»ç»“ä¸è§„åˆ’]
image: https://mongorolls-images.oss-cn-shenzhen.aliyuncs.com/img/cover-8.png
description: æ˜ç™½çœ¼å‰éƒ½æ˜¯æ°”æ³¡ï¼¼å®‰é™çš„æ‰æ˜¯è‹¦å£è‰¯è¯
---

å®ç°åšå®¢æ–‡ä»¶mdç¿»è¯‘éœ€è¦é…ç½®ä¸€å¥—æ¯”è¾ƒå¥½çš„æç¤ºè¯

<!-- truncate -->

## openaiå›½é™…åŒ–ç¿»è¯‘

### ä»£ç 

````js
const { OpenAI } = require('openai')
const { HttpsProxyAgent } = require('https-proxy-agent')
const { i18n } = require('../../next-i18next.config') // ç›´æ¥æ•°ç»„æšä¸¾ä¹Ÿè¡Œ

const fs = require('fs')
const path = require('path')

const myApiKey = 'è‡ªå·±çš„key'
const proxyUrl = 'http://127.0.0.1:7890' // è¿™é‡Œç”¨cfwçš„ç«¯å£å·,éœ€è¦è‡ªå·±å…ˆæœ‰é­”æ³•

const mdxFolderPath = path.resolve(__dirname, '../../pages') // éœ€è¦ç¿»è¯‘çš„æ–‡ä»¶å¤¹è·¯å¾„ ä»¥mdxæ–‡ç« ä¸ºä¾‹
const files = fs.readdirSync(mdxFolderPath) //è¯»å–æŒ‡å®šæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶

const openai = new OpenAI({
  apiKey: myApiKey,
  httpAgent: new HttpsProxyAgent(proxyUrl),
})

const openai = new OpenAI({
  apiKey: myApiKey,
  httpAgent: new HttpsProxyAgent(proxyUrl),
})

const requestChatgpt = async (role, prompt1, prompt2) => {
  const completion = await openai.chat.completions.create({
    model: 'gpt-4o', // é«˜æ€§ä»·
    messages: [
      { role: 'system', content: role },
      {
        role: 'user',
        content: prompt1,
      },
      {
        role: 'user',
        content: prompt2,
      },
    ],
  })
  return completion.choices[0].message.content
}

const translateMDX = async () => {
  //è§’è‰²è®¾å®š
  const role =
    'You are a translator who is familiar with front-end development and markdown. Only give me the text output'
  //æç¤ºè¯åç¼€
  const prompt_suf = 'æ³¨æ„ï¼šè¯·åœ¨mdxé”šç‚¹éœ€è¦æ ¹æ®å½“å‰é¡µé¢çš„çœŸå®è·¯å¾„, å…¶ä¸­languageä¸ºå½“å‰ç¿»è¯‘çš„è¯­è¨€ã€‚'
  const mdxFiles = files.filter(item => item.endsWith('.mdx')) //ç­›é€‰å‡ºçš„mdxæ–‡ä»¶

  for (const fileName of mdxFiles.filter(fname => fname.endsWith('.en.mdx'))) {
    const filePath = path.resolve(mdxFolderPath, fileName)
    // è¯»å–æ–‡ä»¶å†…å®¹
    const prompt_content = fs.readFileSync(filePath, 'utf-8')

    for (const locale of i18n.locales) {
      //è¦ç”Ÿæˆçš„æ–‡ä»¶å
      const newFileName = fileName.replace('.en', `.${locale}`)
      if (mdxFiles.includes(newFileName)) continue //å¦‚æœæƒ³ç¿»è¯‘çš„æ–‡ä»¶å·²ç»å­˜åœ¨ï¼Œåˆ™è·³è¿‡
      //è¦ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„
      const newFilePath = path.resolve(mdxFolderPath, newFileName)

      // ç»„æˆæç¤ºè¯ prompt
      const prompt_pre = `Please translate the content in mdx format into "${locale}" language`
      const prompt = prompt_pre + prompt_suf

      // è°ƒç”¨aiç¿»è¯‘
      try {
        let result = await requestChatgpt(role, prompt, prompt_content)
        // const result = prompt_content; //copyæ–‡ä»¶ç”¨
        result = result.replace('```mdx', '').replace('```', '')
        fs.writeFileSync(newFilePath, result)
        console.log(newFileName + 'å·²ç¿»è¯‘å®Œæˆï¼')
      } catch (err) {
        console.log(fileName + 'ç¿»è¯‘å¤±è´¥ï¼')
      }
    }
  }
}
````

<p align="right">å†™äº2024å¹´9æœˆ5æ—¥    By èŠ’æœğŸ¥­</p>
